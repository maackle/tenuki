{"version":3,"sources":["../src/zobrist.js"],"names":[],"mappings":";;;;;AAAA,IAAM,KAAK,GAAG,EAAE,CAAC;;AAEjB,SAAS,mBAAmB,CAAC,IAAI,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE;AAC9C,OAAK,CAAC,IAAI,CAAC,GAAS,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;AACtC,OAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAM,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACzC,OAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;;AAE5C,MAAI,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;AAC5B,WAAO,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;GACjC;;;;;;AAMD,MAAM,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC,GAAG,CAAC,CAAA,AAAC,CAAC,CAAC;AACtE,OAAK,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,WAAW,CAAC;;AAEvC,SAAO,WAAW,CAAC;CACpB;;qBAEc;AACb,MAAI,EAAE,cAAS,SAAS,EAAE,aAAa,EAAE;AACvC,QAAI,CAAC,GAAG,CAAC,CAAC;;AAEV,iBAAa,CAAC,OAAO,CAAC,UAAA,CAAC,EAAI;AACzB,UAAI,CAAC,CAAC,CAAC,OAAO,EAAE,EAAE;AAChB,YAAM,OAAO,GAAG,mBAAmB,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC;AAClE,SAAC,GAAG,CAAC,GAAG,OAAO,CAAC;OACjB;KACF,CAAC,CAAC;;AAEH,WAAO,CAAC,CAAC;GACV;CACF","file":"zobrist.js","sourcesContent":["const cache = {};\n\nfunction initialBitstringFor(size, y, x, value) {\n  cache[size]       = cache[size] || {};\n  cache[size][y]    = cache[size][y] || {};\n  cache[size][y][x] = cache[size][y][x] || {};\n\n  if (cache[size][y][x][value]) {\n    return cache[size][y][x][value];\n  }\n\n  // The number of legal 19x19 go moves is on the order of 10^170 â‰ˆ 2^565, so\n  // a hash output on the order of 2^31 is woefully insufficient for arbitrary\n  // positions, but it should be good enough for human play, since we're not\n  // searching the entire space. This should be good enough for ~300-move games.\n  const randomValue = Math.floor(Math.random() * (Math.pow(2, 31) - 1));\n  cache[size][y][x][value] = randomValue;\n\n  return randomValue;\n}\n\nexport default {\n  hash: function(boardSize, intersections) {\n    let h = 0;\n\n    intersections.forEach(i => {\n      if (!i.isEmpty()) {\n        const initial = initialBitstringFor(boardSize, i.y, i.x, i.value);\n        h = h ^ initial;\n      }\n    });\n\n    return h;\n  }\n};\n"]}